<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · WRDSMerger.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WRDSMerger.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../download_data/">Downloading WRDS Data</a></li><li><span class="tocitem">Links Between WRDS Data</span><ul><li><a class="tocitem" href="../basic_linking/">Linking Basics</a></li><li><a class="tocitem" href="../default_behavior/">Default Behavior</a></li><li><a class="tocitem" href="../linking_identifiers/">Identifier Types</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Underlying-Methodology-of-convert_identifier"><span>Underlying Methodology of <code>convert_identifier</code></span></a></li><li><a class="tocitem" href="#LinkPairs"><span>LinkPairs</span></a></li><li><a class="tocitem" href="#Linking-Download-Functions"><span>Linking Download Functions</span></a></li><li><a class="tocitem" href="#Changing-The-Priority-for-Permno"><span>Changing The Priority for Permno</span></a></li><li><a class="tocitem" href="#Adding-New-Identifiers"><span>Adding New Identifiers</span></a></li><li><a class="tocitem" href="#Other-Functions"><span>Other Functions</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../misc_utilities/">Miscellaneous Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Links Between WRDS Data</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/junder873/WRDSMerger.jl/blob/master/docs/src/linking_internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linking-Internals"><a class="docs-heading-anchor" href="#Linking-Internals">Linking Internals</a><a id="Linking-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Linking-Internals" title="Permalink"></a></h1><h2 id="Underlying-Methodology-of-convert_identifier"><a class="docs-heading-anchor" href="#Underlying-Methodology-of-convert_identifier">Underlying Methodology of <code>convert_identifier</code></a><a id="Underlying-Methodology-of-convert_identifier-1"></a><a class="docs-heading-anchor-permalink" href="#Underlying-Methodology-of-convert_identifier" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.convert_identifier" href="#WRDSMerger.convert_identifier"><code>WRDSMerger.convert_identifier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_identifier(::Type{ID}, x::T1, dt::Date; vargs...) where {ID&lt;:AbstractIdentifier, T1&lt;:AbstractIdentifier}

convert_identifier(
    ::Type{ID},
    x::T1,
    dt::Date,
    data::Dict{T1, Vector{&lt;:AbstractLinkPair{T1, ID}}}=data;
    vargs...
) where {ID&lt;:AbstractIdentifier, T1&lt;:AbstractIdentifier}</code></pre><p>Converts an identifier (T1) to a different identifier (ID). In its most generic form, this throws a <code>MethodError</code> implying there is not a function that exists to directly link T1 -&gt; ID.</p><p>Calling <a href="#WRDSMerger.new_link_method"><code>new_link_method</code></a> calls a macro to create different versions of <code>convert_identifier</code> to provide links between identifiers. If these are direct links (which means there is a  <code>AbstractLinkPair</code> that links the two identifiers, such as Permno -&gt; Permco or Permno -&gt; NCusip), then this provides a one step method to link these two identifiers.</p><p>For other identifiers, there is not a link table that provides a direct link (such as SecID -&gt; GVKey). In those cases, <code>new_link_method</code> will find a path between the two (in the case of SecID -&gt; GVKey, SecID -&gt; NCusip -&gt; Permno -&gt; GVKey). Each case of <code>convert_identifier</code> only does 1 step in the process, so <code>convert_identifier(GVKey, SecID(1), today())</code> would call <code>convert_identifier(Permno, SecID(1), today())</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are two slightly different behaviors for the direct links of <code>convert_identifier</code>. When linking a <code>SecurityIdentifier</code> -&gt; <code>FirmIdentifier</code>, the function might retry if a link is not found with the parent identifier of the security. For example, when trying to link NCusip -&gt; GVKey, the default behavior is to try NCusip -&gt; Permno -&gt; GVKey. However, suppose there is not a matching NCusip -&gt; Permno, the function will try again with NCusip6 -&gt; Permno. The logic is that it should not matter if the Permno does not perfectly match the NCusip if the end goal is  to find a relevant GVKey. This behavior can be disabled by using <code>allow_parent_firm=false</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/linkMethods.jl#L2-L42">source</a></section></article><h2 id="LinkPairs"><a class="docs-heading-anchor" href="#LinkPairs">LinkPairs</a><a id="LinkPairs-1"></a><a class="docs-heading-anchor-permalink" href="#LinkPairs" title="Permalink"></a></h2><p>This packages primary storage method for links is an <code>AbstractLinkPair</code>, which is typically a <code>LinkPair</code>:</p><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.LinkPair" href="#WRDSMerger.LinkPair"><code>WRDSMerger.LinkPair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function LinkPair(
    parent::T1,
    child::T2,
    dt1::Union{Missing, Date, String}=Date(0, 1, 1),
    dt2::Union{Missing, Date, String}=Date(9999, 12, 31),
    priority::Real=0.0
) where {T1&lt;:AbstractIdentifier, T2&lt;:AbstractIdentifier}

function LinkPair(
    parent::T1,
    child::T2,
    dt1::Union{Missing, Date, String},
    dt2::Union{Missing, Date, String},
    linkprim::String,
    linktype::String,
) where {T1&lt;:Union{GVKey, Permno, Permco}, T2&lt;:Union{GVKey, Permno, Permco}}</code></pre><p><code>LinkPair</code> is the basic structure that provides a link between two identifiers. These are defined as a single direction link (T1 -&gt; T2) that is valid between a specific date range (inclusive) and has a given priority (higher is better). Priority is useful if there are overlapping T1 -&gt; T2 items. For example, a <a href="../linking_identifiers/#WRDSMerger.FirmIdentifier"><code>FirmIdentifier</code></a> likely has multiple <a href="../linking_identifiers/#WRDSMerger.SecurityIdentifier"><code>SecurityIdentifier</code></a>s that relate to it. One common way to pick between different <code>SecurityIdentifier</code>s is to pick the one with the large market cap as the primary.</p><p>If defining a new identifier that has other methods of choosing priorities (such as a String indicating priority), it can help to define a function that converts these strings into a number. An example of this exists for linking GVKey -&gt; Permno or Permco (and the reverse), which take in <code>linkprim</code> and <code>linktype</code> and convert those to the appropriate priority.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/linkPairs.jl#L44-L75">source</a></section></article><p>Conceptually, a <code>LinkPair</code> provides a one direction link between T1 -&gt; T2. These are typically stored in a dictionary for quick lookup:</p><pre><code class="language-julia hljs">Dict{T1, Vector{LinkPair{T1, T2}}}()</code></pre><p>and this package adds a function to <code>Dict</code> to convert an abstract vector of <code>LinkPair</code>s to such a dictionary:</p><article class="docstring"><header><a class="docstring-binding" id="Base.Dict" href="#Base.Dict"><code>Base.Dict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dict(data::AbstractVector{L}) where {T1, T2, L&lt;:AbstractLinkPair{T1, T2}}</code></pre><p>Converts a vector of <code>AbstractLinkPair</code>s to a dictionary where each T1 is a key in the dictionary and the values are vectors of L. It also checks whether those vectors ever have overlapping inconsistent priorities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/creatingLinks.jl#L63-L69">source</a></section></article><h3 id="Defining-New-AbstractLinkPairs"><a class="docs-heading-anchor" href="#Defining-New-AbstractLinkPairs">Defining New <code>AbstractLinkPair</code>s</a><a id="Defining-New-AbstractLinkPairs-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-New-AbstractLinkPairs" title="Permalink"></a></h3><p>While this package currently makes use of <code>LinkPair</code>, it might be easier for other identifiers to define a more complex <code>AbstractLinkPair</code>. A key component of an <code>AbstractLinkPair</code> is being able to compare when one link should be used as opposed to another, which this package refers to as priority. In some cases, there might be multiple values that determine a priority. For example, the link between <a href="../linking_identifiers/#WRDSMerger.GVKey"><code>GVKey</code></a> &lt;-&gt; <a href="../linking_identifiers/#WRDSMerger.Permno"><code>Permno</code></a> has two columns, depending on the direction (e.g., going from <code>Permno</code> -&gt; <code>GVKey</code>, &quot;LC&quot; &gt; &quot;LU&quot; &gt; &quot;LS&quot;...). This package converts these into a single number with decimals (&quot;LC&quot; = 8, &quot;LU&quot; = 7... and the other column, &quot;P&quot; = 0.3, &quot;C&quot; = 0.2 ..., added together). This is switched when defining the link between <code>GVKey</code> -&gt; <code>Permno</code> (&quot;LC&quot; = 0.8, &quot;P&quot; = 3). An alternative way to define this would be to create a separate <code>AbstractLinkPair</code> type that would avoid adding and, perhaps, be clearer on methodology. For example, something like:</p><pre><code class="language-julia hljs">struct CrspCompLinkPair{T1&lt;:AbstractIdentifier, T2&lt;:AbstractIdentifier} &lt;: AbstractLinkPair{T1, T2}
    parent::T1
    child::T2
    dt1::Date# first date valid
    dt2::Date# last date valid
    comp_crsp_priority::Int
    crsp_comp_priority::Int
    function CrspCompLinkPair(
        t1::T1,
        t2::T2,
        dt1::Date,
        dt2::Date,
        linktype::AbstractString,
        linkprim::AbstractString
    ) where {T1, T2}
        comp_crsp_priority = if linkprim == &quot;P&quot;
            3
        elseif linkprim == &quot;C&quot;
            2
        elseif linkprim == &quot;J&quot;
            1
        end
        crsp_comp_priority = if linktype == &quot;LC&quot;
            8
        elseif linktype == &quot;LU&quot;
            7
        elseif linktype == &quot;LS&quot;
            6
        elseif linktype == &quot;LX&quot;
            5
        elseif linktype == &quot;LD&quot;
            4
        elseif linktype == &quot;LN&quot;
            3
        elseif linktype == &quot;NR&quot;
            2
        elseif linktype == &quot;NU&quot;
            1
        end
        new{T1, T2}(t1, t2, dt1, dt2, comp_crsp_priority, crsp_comp_priority)
    end
end</code></pre><p>While most of the default functions for <code>AbstractLinkPair</code> would work with this new type (<code>parentID</code>, <code>childID</code>, <code>min_date</code>, <code>max_date</code>, <code>Base.in</code>), the one that does not is <code>priority</code>, which determines which <code>AbstractLinkPair</code> is preferable. Since the direction of the link matters, two new <code>priority</code> functions are required:</p><pre><code class="language-julia hljs">function WRDSMerger.priority(data::CrspCompLinkPair{GVKey, T2}) where {T2&lt;:AbstractIdentifier}
    data.comp_crsp_priority + data.crsp_comp_priority / 10
end

function WRDSMerger.priority(data::CrspCompLinkPair{T1, GVKey}) where {T1&lt;:AbstractIdentifier}
    data.crsp_comp_priority + data.comp_crsp_priority / 10
end</code></pre><p>While this case is not used by default in this package, following similar methodology could allow for more complex priority structures.</p><h2 id="Linking-Download-Functions"><a class="docs-heading-anchor" href="#Linking-Download-Functions">Linking Download Functions</a><a id="Linking-Download-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Linking-Download-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.download_crsp_links" href="#WRDSMerger.download_crsp_links"><code>WRDSMerger.download_crsp_links</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_crsp_links(db; main_table=&quot;crsp.stocknames&quot;, stockfile=&quot;crsp.dsf&quot;)</code></pre><p>Runs the following SQL code (tables are changeable by setting the <code>main_table</code> and <code>stockfile</code> keyword arguments):</p><pre><code class="language-sql hljs">select a.*, b.mkt_cap from crsp.stocknames a
        left join (
            select s.permno, s.namedt, s.nameenddt, avg(d.mkt_cap) as mkt_cap from crsp.stocknames s
                inner join (select permno, date, abs(prc) * shrout as mkt_cap from crsp.dsf) as d
                on s.permno = d.permno and s.namedt &lt;= d.date and s.nameenddt &gt;= d.date
            group by s.permno, s.namedt, s.nameenddt
            ) b
            on a.permno = b.permno and a.namedt = b.namedt and a.nameenddt = b.nameenddt</code></pre><p>and returns a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/downloadLinks.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.download_comp_crsp_links" href="#WRDSMerger.download_comp_crsp_links"><code>WRDSMerger.download_comp_crsp_links</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_comp_crsp_links(db; main_table=&quot;crsp_a_ccm.ccmxpf_linkhist&quot;)</code></pre><p>Runs the following SQL code (table is changeable by setting the <code>main_table</code> keyword argument):</p><pre><code class="language-sql hljs">SELECT * FROM crsp_a_ccm.ccmxpf_linkhist</code></pre><p>and returns the resulting DataFrame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/downloadLinks.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.download_comp_cik_links" href="#WRDSMerger.download_comp_cik_links"><code>WRDSMerger.download_comp_cik_links</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_comp_cik_links(db; main_table=&quot;comp.company&quot;)</code></pre><p>Runs the following SQL code (table is changeable by setting the <code>main_table</code> keyword argument):</p><pre><code class="language-sql hljs">SELECT * FROM comp.company</code></pre><p>and returns the resulting DataFrame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/downloadLinks.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.download_ibes_links" href="#WRDSMerger.download_ibes_links"><code>WRDSMerger.download_ibes_links</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_ibes_links(db; main_table=&quot;wrdsapps.ibcrsphist&quot;)</code></pre><p>Runs the following SQL code (table is changeable by setting the <code>main_table</code> keyword argument):</p><pre><code class="language-sql hljs">SELECT * FROM wrdsapps.ibcrsphist</code></pre><p>and returns the resulting DataFrame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/downloadLinks.jl#L63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.download_option_crsp_links" href="#WRDSMerger.download_option_crsp_links"><code>WRDSMerger.download_option_crsp_links</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_option_crsp_links(db; main_table=&quot;optionm_all.secnmd&quot;)</code></pre><p>Runs the following SQL code (table is changeable by setting the <code>main_table</code> keyword argument):</p><pre><code class="language-sql hljs">SELECT * FROM optionm_all.secnmd</code></pre><p>and returns the resulting DataFrame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/downloadLinks.jl#L77-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.download_ravenpack_links" href="#WRDSMerger.download_ravenpack_links"><code>WRDSMerger.download_ravenpack_links</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_ravenpack_links(db; main_table=&quot;ravenpack.rp_entity_mapping&quot;, cusip_list=&quot;crsp.stocknames&quot;)</code></pre><p>Runs the following SQL code (tables are changeable by setting the <code>main_table</code> and <code>cusip_list</code> keyword arguments):</p><pre><code class="language-sql hljs">SELECT rp_entity_id, data_value as ncusip, range_start, range_end FROM ravenpack.rp_entity_mapping as a
            inner join (select distinct ncusip from crsp.stocknames) as b
            on left(a.data_value, 8) = b.ncusip</code></pre><p>and returns a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/downloadLinks.jl#L91-L102">source</a></section></article><h2 id="Changing-The-Priority-for-Permno"><a class="docs-heading-anchor" href="#Changing-The-Priority-for-Permno">Changing The Priority for Permno</a><a id="Changing-The-Priority-for-Permno-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-The-Priority-for-Permno" title="Permalink"></a></h2><p>A single company can have many securities, therefore, there might be multiple options when linking these items. For example, a single <a href="../linking_identifiers/#WRDSMerger.GVKey"><code>GVKey</code></a> or <a href="../linking_identifiers/#WRDSMerger.Permco"><code>Permco</code></a> will match to multiple <a href="../linking_identifiers/#WRDSMerger.Permno"><code>Permno</code></a>s. In some tables in WRDS (such as in the case of <code>GVKey</code> &lt;-&gt; <code>Permno</code>), there are explicit primary identifier markers provided, improving the match. In others, there are not (as in <code>Permco</code> &lt;-&gt; <code>Permno</code>). This is a particular problem for <code>Permno</code> since this package prioritizes matches through <code>Permno</code> (as discussed in <a href="../default_behavior/#Supremacy-of-Permno">Supremacy of Permno</a>).</p><p>The most common method to resolve these matches is to find the <code>Permno</code> that has the largest market capitalization on the day of the match since that should be the primary identifier. This is difficult to do in a package like this where the values are, ideally, predetermined. Therefore, the default behavior is to average the market capitalization over the period of the link and choose the higher average market capitalization. This behavior is convenient (requiring only a single SQL download), but potentially inconsistent with the end goal. Specifically, if one link has a lower average market capitalization (perhaps due to a long time window where the value was lower) than another link, this package might pick the <code>Permno</code> with a smaller market capitalization on the day of the match.</p><p>This is a proposed alternative that makes use of the <a href="https://github.com/junder873/AbnormalReturns.jl">AbnormalReturns.jl</a> package to provide a quick lookup of the market capitalization just before the link:</p><p>First, stock price data is required:</p><pre><code class="language-julia hljs">using WRDSMerger, DataFramesMeta, AbnormalReturns
df = raw_sql(wrds_conn, &quot;SELECT permno, date, abs(prc) * shrout AS mkt_cap FROM crsp.dsf&quot;)
@rtransform!(df, :mkt_cap = coalesce(:mkt_cap, 0.0))</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is recommended to provide some filter on the WRDS download as the <code>crsp.dsf</code> file has over 100 million rows, downloading this data takes a lot of ram, peaking at ~20 GB. Most obviously, selecting dates beyond a certain point helps a lot.</p></div></div><p>AbnormalReturns needs a market calendar, instead of downloading something, just reuse the dates from <code>df</code> and load that into a <code>MarketData</code> object:</p><pre><code class="language-julia hljs">mkt_data = MarketData(
    @by(df, :date, :full_mkt = mean(:mkt_cap)),
    df
)</code></pre><p>Then we need to redefine how WRDSMerger goes about choosing between two links when the outcome is a <code>Permno</code>. It is also important to do some error checking since AbnormalReturns does not accept cases when the date is out of the range available or the <code>Permno</code> is not in the dataset. WRDSMerger determines priority uses the <code>is_higher_priority</code> function, which checks the priority of two <code>AbstractLinkPair</code>s and compares them. Therefore, changing the <code>priority</code> function slightly when the outcome is a <code>Permno</code> will create the necessary changes:</p><pre><code class="language-julia hljs">function WRDSMerger.priority(
    data::AbstractLinkPair{T1, Permno},
    dt::Date;
    mkt_data=mkt_data # need the market data defined above
) where {T1}
    if dt &lt; AbnormalReturns.cal_dt_min(mkt_data.calendar) || dt &gt; AbnormalReturns.cal_dt_min(mkt_data.calendar)
        return 0.0
    end
    if dt &gt; AbnormalReturns.cal_dt_min(mkt_data.calendar)
        # typically, the market cap on the day before is checked
        # but it is also important to avoid going outside the calendar
        # range
        dt = BusinessDays.advancebdays(mkt_data.calendar, dt, -1)
    end
    permno_val = WRDSMerger.childID(data)
    if haskey(mkt_data.firmdata, permno_val)
        coalesce(
            mkt_data[permno_val, dt, :mkt_cap], # returns value or missing
            0.0
        )
    else
        0.0
    end
end</code></pre><p>This method is obviously slower than the default setup, but would provide the market capitalization on the day before the match.</p><p>This is not the default in this package since many of these operations are costly, particularly downloading the data.</p><h2 id="Adding-New-Identifiers"><a class="docs-heading-anchor" href="#Adding-New-Identifiers">Adding New Identifiers</a><a id="Adding-New-Identifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-New-Identifiers" title="Permalink"></a></h2><p>There are likely other identifiers in WRDS that are not included by default in this package, making it necessary to define a new identifier. This is quite easy. First, define a new type:</p><pre><code class="language-julia hljs">struct IdentiferName &lt;: FirmIdentifier
    val::String
    IdentifierName(x::AbstractString) = new(x)
end

WRDSMerger.value(x::IdentifierName) = x.val</code></pre><p>Replacing <code>FirmIdentifier</code> with <code>SecurityIdentifier</code> if necessary and choosing between <code>String</code> or <code>Int</code> or some other type.</p><p>Next, provide the information that links this new identifier to some other identifier in the package. This is done by calling <code>new_link_method</code>:</p><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.new_link_method" href="#WRDSMerger.new_link_method"><code>WRDSMerger.new_link_method</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_link_method(data::Vector{L}) where {L&lt;:AbstractLinkPair}

new_link_method(data::Dict{T1, Vector{L}}) where {T1, ID, L&lt;:AbstractLinkPair{T1, ID}}

function new_link_method(
    ::Type{T1},
    ::Type{ID};
    current_links = all_pairs(AbstractIdentifier, AbstractIdentifier)
) where {ID&lt;:AbstractIdentifier, T1&lt;:AbstractIdentifier}</code></pre><p>Creates a new <a href="#WRDSMerger.convert_identifier"><code>convert_identifier</code></a> method to link T1 -&gt; ID. See detailed notes under <code>convert_identifier</code>. If a vector of <code>AbstractLinkPair</code> or a dictionary is passed, this creates a direct link method, while passing two types will attempt to find a path between the two identifiers and define the appropriate function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="#WRDSMerger.all_pairs"><code>all_pairs</code></a> is a relatively slow function, needing to repeatedly check what methods are available. Therefore, if needing to create many new methods, it is best to run <code>all_pairs</code> once and pass that for each new T1 -&gt; ID that needs to be created.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/linkMethods.jl#L56-L78">source</a></section></article><p>Specifically the method with a vector of <code>AbstractLinkPair</code>s or the dictionary version. Therefore, you need to create a vector of these links, I will assume use of the <code>LinkPair</code> type, but this can be adjusted as discussed in <a href="#Defining-New-AbstractLinkPairs">Defining New <code>AbstractLinkPair</code>s</a>. A <code>LinkPair</code> requires 5 elements: the ID it is coming from (parent ID), the ID it is going to (child ID), a start and end date, and a priority (though the start and end date and priority have defaults). Therefore, it is easiest if you create a DataFrame that has similar data (i.e., a column of parent ID, child ID, start date, end date, priority). This package then has a function that allows you to create the bi-directional links required, <code>create_link_pair</code>:</p><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.create_link_pair" href="#WRDSMerger.create_link_pair"><code>WRDSMerger.create_link_pair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function create_link_pair(
    ::Type{LP},
    ::Type{T1},
    ::Type{T2},
    df::DataFrame,
    cols...
) where {T1&lt;:AbstractIdentifier, T2&lt;:AbstractIdentifier, LP&lt;:AbstractLinkPair}</code></pre><p>Generic function that creates an AbstractLinkPair based on the types and a DataFrame. <code>cols...</code> should be a list of column names in the DataFrame, the first being ready to convert to type T1 and the second ready to convert to type T2. This function returns a tuple of two dictionaries: <code>(Dict{T1, LP{T1, T2}},Dict{T2, LP{T2, T1}})</code> which is easily passed to <a href="#WRDSMerger.new_link_method"><code>new_link_method</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">create_link_pair(
    LinkPair,
    Permno,
    NCusip,
    df,
    :permno,
    :ncusip,
    :namedt,
    :nameenddt,
    :priority
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/creatingLinks.jl#L87-L117">source</a></section></article><p>Since this returns a tuple of dictionaries, each needs to be passed to <code>new_link_method</code> to create the bidirectional links. Then, to create links beyond just T1 &lt;-&gt; T2, call <code>create_all_links()</code>.</p><h2 id="Other-Functions"><a class="docs-heading-anchor" href="#Other-Functions">Other Functions</a><a id="Other-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.choose_best_match" href="#WRDSMerger.choose_best_match"><code>WRDSMerger.choose_best_match</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function choose_best_match(
    data::AbstractVector{L},
    dt::Date;
    allow_inexact_date=true,
    args...
) where {L&lt;:AbstractLinkPair}</code></pre><p>Picks the best identifier based on the vector of links provided.</p><p><strong>Args</strong></p><ul><li><code>allow_inexact_date=true</code>: If true, and the length of the supplied vector is 1, then is will return that value even if the supplied date does not fit within the link.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/linkMethods.jl#L260-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.check_priority_errors" href="#WRDSMerger.check_priority_errors"><code>WRDSMerger.check_priority_errors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function tests whether there are any dates that are in multiple <code>AbstractLinkPair</code>s and those links have equivalent priority. If this function returns <code>true</code>, then there is at least a date where there is no distinction between two links. The way <a href="#WRDSMerger.choose_best_match"><code>choose_best_match</code></a> works, the first in the vector will be chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/creatingLinks.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.is_higher_priority" href="#WRDSMerger.is_higher_priority"><code>WRDSMerger.is_higher_priority</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_higher_priority(
    data1::AbstractLinkPair{T1, T2},
    data2::AbstractLinkPair{T1, T2},
    args...
) where {T1, T2}</code></pre><p>Determines whether data1 has higher priority than data2. <code>args...</code> are automatically passed to the <code>priority</code>function, which can then deal with special circumstances (currently passed as the date of the match). However, none of the default settings use this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/linkPairs.jl#L22-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.identify_overlaps" href="#WRDSMerger.identify_overlaps"><code>WRDSMerger.identify_overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function looks for overlapping periods. It takes a list of all dates and checks if individual sub periods are a subset of multiple periods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/creatingLinks.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.value" href="#WRDSMerger.value"><code>WRDSMerger.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value(x::AbstractIdentifier)</code></pre><p>Converts an identifier into a common Julia type (typically <code>Int</code> or <code>String</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/identifierTypes.jl#L669-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WRDSMerger.all_pairs" href="#WRDSMerger.all_pairs"><code>WRDSMerger.all_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function all_pairs(
    a::Type{&lt;:AbstractIdentifier},
    b::Type{&lt;:AbstractIdentifier};
    out = Vector{Tuple{DataType, DataType}}(),
    test_fun=base_method_exists
)</code></pre><p>Generates a vector of tuples for which a method exists. It specifically looks for base types (not abstract types).</p><p><code>test_fun</code> has two values defined:</p><ul><li><code>base_method_exists</code> looks for methods that have the two types provided   and that link is a direct link (e.g., Permno &lt;-&gt; NCusip), as opposed to a   method that takes more than a single step</li><li><code>method_is_missing</code> looks for methods that do not exist, this is designed to   look for cases where a new method is needed, typically taking more than a   single step to complete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junder873/WRDSMerger.jl/blob/c7dd1958b600c41feae04936defe796268cf3591/src/links/linkMethods.jl#L157-L175">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linking_identifiers/">« Identifier Types</a><a class="docs-footer-nextpage" href="../misc_utilities/">Miscellaneous Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 20 April 2023 23:01">Thursday 20 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
