var documenterSearchIndex = {"docs":
[{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"data_dir = joinpath(\"..\", \"..\", \"test\", \"data\")\nusing CSV, DataFrames, WRDSMerger, Dates\nfiles = [\n    \"crsp_links\",\n    \"crsp_comp_links\",\n    \"gvkey_cik_links\",\n]\nfuns=[\n    generate_crsp_links,\n    generate_comp_crsp_links,\n    generate_comp_cik_links,\n]\nfor (file, fun) in zip(files, funs)\n    fun(\n        DataFrame(\n            CSV.File(joinpath(data_dir, file * \".csv\"))\n        )\n    )\nend\ncreate_all_links()","category":"page"},{"location":"basic_linking/#Basics-of-Linking-Identifiers","page":"Linking Basics","title":"Basics of Linking Identifiers","text":"","category":"section"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"A core part of this package is to provide a simple and consistent interface for linking different identifiers in WRDS. One of the primary goals is to reduce the overhead of remembering how exactly to link one dataset to another.","category":"page"},{"location":"basic_linking/#Downloading-and-Saving-Data","page":"Linking Basics","title":"Downloading and Saving Data","text":"","category":"section"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"To do so, first download the necessary data from WRDS. This package provides download functions to do so (see Linking Download Functions), which are automatically called by respective generating functions (see Generating LinkPair Functions). The generating functions take in a DataFrame (which expects certain column names) and creates the necessary functions between its identifiers. Finally, calling create_all_links() will create the remaining links that the tables do not provide.","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"To provide an example:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"julia> db = ODBC.Connection(\"wrds-pgdata-64\");\njulia> generate_crsp_links(db) # downloads the data, creates links between \n# Permno <-> Permco, Permno <-> NCusip, etc.\n# and returns the data that is downloaded\n\njulia> generate_comp_crsp_links(db) # similar to generate_crsp_links\n\njulia> create_all_links() # defines functions between NCusip <-> GVKey, \n# Ticker <-> GVKey, etc.","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"The generate functions return the DataFrame that is downloaded so you can save it locally (with CSV.jl, Arrow.jl, etc.) and can use again as opposed to re-downloading the data.","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"This package also provides a simple function that runs all of these:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"julia> download_all_links(db)","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"Which downloads all 6 default tables and returns those 6 DataFrames. Note that if your WRDS account lacks access to one of the tables, you need to change which items are downloaded.","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"For example, the code I use when starting a project is:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"data_dir = joinpath(path_to_saved_files)\ndfs = download_all_links(db)\nfiles = [\n    \"crsp_links\",\n    \"crsp_comp_links\",\n    \"gvkey_cik_links\",\n    \"ibes_links\",\n    \"option_links\",\n    \"ravenpack_links\"\n]\n# I prefer Arrow.jl and feather files, replace with CSV.jl if desired\nfor (df, file) in zip(dfs, files)\n    Arrow.write(joinpath(data_dir, file * \".feather\"), df)\nend","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"Then, whenever I reload the project:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"funs=[\n    generate_crsp_links,\n    generate_comp_crsp_links,\n    generate_comp_cik_links,\n    generate_ibes_links,\n    generate_option_crsp_links,\n    generate_ravenpack_links\n]\nfor (file, f) in zip(files, funs)\n    @chain joinpath(data_dir, file * \".feather\") begin\n        Arrow.Table\n        DataFrame\n        copy\n        f\n    end\nend\ncreate_all_links()","category":"page"},{"location":"basic_linking/#Linking-Identifiers","page":"Linking Basics","title":"Linking Identifiers","text":"","category":"section"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"Once the initial data is downloaded and necessary functions are created, the package provides a consistent set of methods to convert one identifier to any other. This follows the pattern:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"(ID You Want)((ID You Have)(value), Date for conversion)","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"For example:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"GVKey(Permno(47896), Date(2020))\nNCusip(CIK(19617), Date(2020)) # works for Int or String\nCIK(Permno(47896), Date(2020))\nCIK(NCusip(\"46625H21\"), Date(2020))","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"As you can see, this includes cases where there is not a table providing a direct link (CIK <-> Permno, CIK <-> NCusip). This makes it easy to link the varied datasets in WRDS.","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"These functions can be easily used with broadcasting:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"GVKey.(Permno.([47896, 44206, 46703]), Date(2020))\nGVKey.(Permno.([47896, 44206, 46703]), [Date(2018), Date(2019), Date(2020)])","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"Or with other packages such as DataFramesMeta.jl:","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"@chain df begin\n    @rtransform(:gvkey = GVKey(Permno(:permno), :date))\nend","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"All of the identifiers that this package provides by default are seen in Identifier Types. This is expandable as discussed in Adding New Identifiers.","category":"page"},{"location":"basic_linking/#Generating-LinkPair-Functions","page":"Linking Basics","title":"Generating LinkPair Functions","text":"","category":"section"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"This section describes the default functions that exist to generate the necessary links.","category":"page"},{"location":"basic_linking/","page":"Linking Basics","title":"Linking Basics","text":"generate_crsp_links\ngenerate_comp_crsp_links\ngenerate_comp_cik_links\ngenerate_ibes_links\ngenerate_option_crsp_links\ngenerate_ravenpack_links","category":"page"},{"location":"basic_linking/#WRDSMerger.generate_crsp_links","page":"Linking Basics","title":"WRDSMerger.generate_crsp_links","text":"generate_crsp_links(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    main_table=default_tables[\"crsp_stocknames\"],\n    stockfile=default_tables[\"crsp_stock_data\"]\n)\n\ngenerate_crsp_links(df::AbstractDataFrame)\n\nGenerates the methods linking  Permno, Permco, Cusip, NCusip, Cusip6, NCusip6 and Ticker to each other. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\nThe file used (crsp.stocknames), does not have a clear way to differentiate different priorities. The most common way is to calculate the market cap of any conflicting securities to determine the best option. The ideal is the market cap on the relevant day, but since this needs a static value, the default download is to average the market cap over the relevant period.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_comp_crsp_links","page":"Linking Basics","title":"WRDSMerger.generate_comp_crsp_links","text":"generate_comp_crsp_links(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    main_table=default_tables[\"crsp_a_ccm_ccmxpf_lnkhist\"]\n)\n\ngenerate_comp_crsp_links(df::AbstractDataFrame)\n\nGenerates the methods linking GVKey and Permno/Permco based on  the CRSP/Compustat merged annual file link history (crsp_a_ccm.ccmxpf_lnkhist). If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_comp_cik_links","page":"Linking Basics","title":"WRDSMerger.generate_comp_cik_links","text":"generate_comp_cik_links(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    main_table=default_tables[\"comp_company\"]\n)\n\ngenerate_comp_cik_links(df::AbstractDataFrame)\n\nGenerates the methods linking GVKey and CIK based on  the Compustat company name file (comp.company). GVKey and CIK do not have any date conditions, so this download is relatively simple. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_ibes_links","page":"Linking Basics","title":"WRDSMerger.generate_ibes_links","text":"generate_ibes_links(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    main_table=default_tables[\"wrdsapps_ibcrsphist\"]\n)\n\ngenerate_ibes_links(df::AbstractDataFrame)\n\nGenerates the methods between IbesTicker and Permno/NCusip based on a standard WRDS file. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_option_crsp_links","page":"Linking Basics","title":"WRDSMerger.generate_option_crsp_links","text":"generate_option_crsp_links(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    main_table=default_tables[\"optionm_all_secnmd\"]\n)\n\ngenerate_option_crsp_links(df::AbstractDataFrame)\n\nGenerates the methods linking SecID and NCusip based on  the option names file (optionm_all.secnmd). This file only provides an \"effective date\", so it is assumed that once the next \"effective date\"  occurs, the link is no longer valid. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_ravenpack_links","page":"Linking Basics","title":"WRDSMerger.generate_ravenpack_links","text":"generate_ravenpack_links(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    main_table=default_tables[\"ravenpack_common_rp_entity_mapping\"]\n)\n\ngenerate_ravenpack_links(df::AbstractDataFrame)\n\nGenerates the methods linking RPEntity and NCusip6 based on  the RavenPack Entity Mapping file (ravenpack_common.rp_entity_mapping). This file is very messy, so the automatic options make several assumptions and filters. First, when downloading the data, it filters any NCusip in the RavenPack file that is not in the crsp.stocknames file. Second, for each RPEntity, if the end date is missing, it assumes the next start date is the appropriate end date for the link. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#Linking-Internals","page":"Internals","title":"Linking Internals","text":"","category":"section"},{"location":"linking_internals/#Underlying-Methodology-of-convert_identifier","page":"Internals","title":"Underlying Methodology of convert_identifier","text":"","category":"section"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"WRDSMerger.convert_identifier","category":"page"},{"location":"linking_internals/#WRDSMerger.convert_identifier","page":"Internals","title":"WRDSMerger.convert_identifier","text":"convert_identifier(::Type{ID}, x::T1, dt::Date; vargs...) where {ID<:AbstractIdentifier, T1<:AbstractIdentifier}\n\nconvert_identifier(\n    ::Type{ID},\n    x::T1,\n    dt::Date,\n    data::Dict{T1, Vector{<:AbstractLinkPair{T1, ID}}}=data;\n    vargs...\n) where {ID<:AbstractIdentifier, T1<:AbstractIdentifier}\n\nConverts an identifier (T1) to a different identifier (ID). In its most generic form, this throws a MethodError implying there is not a function that exists to directly link T1 -> ID.\n\nCalling new_link_method calls a macro to create different versions of convert_identifier to provide links between identifiers. If these are direct links (which means there is a  AbstractLinkPair that links the two identifiers, such as Permno -> Permco or Permno -> NCusip), then this provides a one step method to link these two identifiers.\n\nFor other identifiers, there is not a link table that provides a direct link (such as SecID -> GVKey). In those cases, new_link_method will find a path between the two (in the case of SecID -> GVKey, SecID -> NCusip -> Permno -> GVKey). Each case of convert_identifier only does 1 step in the process, so convert_identifier(GVKey, SecID(1), today()) would call convert_identifier(Permno, SecID(1), today()).\n\nnote: Note\nThere are two slightly different behaviors for the direct links of convert_identifier. When linking a SecurityIdentifier -> FirmIdentifier, the function might retry if a link is not found with the parent identifier of the security. For example, when trying to link NCusip -> GVKey, the default behavior is to try NCusip -> Permno -> GVKey. However, suppose there is not a matching NCusip -> Permno, the function will try again with NCusip6 -> Permno. The logic is that it should not matter if the Permno does not perfectly match the NCusip if the end goal is  to find a relevant GVKey. This behavior can be disabled by using allow_parent_firm=false.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#LinkPairs","page":"Internals","title":"LinkPairs","text":"","category":"section"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"This packages primary storage method for links is an AbstractLinkPair, which is typically a LinkPair:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"LinkPair","category":"page"},{"location":"linking_internals/#WRDSMerger.LinkPair","page":"Internals","title":"WRDSMerger.LinkPair","text":"function LinkPair(\n    parent::T1,\n    child::T2,\n    dt1::Union{Missing, Date, String}=Date(0, 1, 1),\n    dt2::Union{Missing, Date, String}=Date(9999, 12, 31),\n    priority::Real=0.0\n) where {T1<:AbstractIdentifier, T2<:AbstractIdentifier}\n\nfunction LinkPair(\n    parent::T1,\n    child::T2,\n    dt1::Union{Missing, Date, String},\n    dt2::Union{Missing, Date, String},\n    linkprim::String,\n    linktype::String,\n) where {T1<:Union{GVKey, Permno, Permco}, T2<:Union{GVKey, Permno, Permco}}\n\nLinkPair is the basic structure that provides a link between two identifiers. These are defined as a single direction link (T1 -> T2) that is valid between a specific date range (inclusive) and has a given priority (higher is better). Priority is useful if there are overlapping T1 -> T2 items. For example, a FirmIdentifier likely has multiple SecurityIdentifiers that relate to it. One common way to pick between different SecurityIdentifiers is to pick the one with the large market cap as the primary.\n\nIf defining a new identifier that has other methods of choosing priorities (such as a String indicating priority), it can help to define a function that converts these strings into a number. An example of this exists for linking GVKey -> Permno or Permco (and the reverse), which take in linkprim and linktype and convert those to the appropriate priority.\n\n\n\n\n\n","category":"type"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Conceptually, a LinkPair provides a one direction link between T1 -> T2. These are typically stored in a dictionary for quick lookup:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Dict{T1, Vector{LinkPair{T1, T2}}}()","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"and this package adds a function to Dict to convert an abstract vector of LinkPairs to such a dictionary:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Dict","category":"page"},{"location":"linking_internals/#Base.Dict","page":"Internals","title":"Base.Dict","text":"Dict(data::AbstractVector{L}) where {T1, T2, L<:AbstractLinkPair{T1, T2}}\n\nConverts a vector of AbstractLinkPairs to a dictionary where each T1 is a key in the dictionary and the values are vectors of L. It also checks whether those vectors ever have overlapping inconsistent priorities.\n\n\n\n\n\n","category":"type"},{"location":"linking_internals/#Defining-New-AbstractLinkPairs","page":"Internals","title":"Defining New AbstractLinkPairs","text":"","category":"section"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"While this package currently makes use of LinkPair, it might be easier for other identifiers to define a more complex AbstractLinkPair. A key component of an AbstractLinkPair is being able to compare when one link should be used as opposed to another, which this package refers to as priority. In some cases, there might be multiple values that determine a priority. For example, the link between GVKey <-> Permno has two columns, depending on the direction (e.g., going from Permno -> GVKey, \"LC\" > \"LU\" > \"LS\"...). This package converts these into a single number with decimals (\"LC\" = 8, \"LU\" = 7... and the other column, \"P\" = 0.3, \"C\" = 0.2 ..., added together). This is switched when defining the link between GVKey -> Permno (\"LC\" = 0.8, \"P\" = 3). An alternative way to define this would be to create a separate AbstractLinkPair type that would avoid adding and, perhaps, be clearer on methodology. For example, something like:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"struct CrspCompLinkPair{T1<:AbstractIdentifier, T2<:AbstractIdentifier} <: AbstractLinkPair{T1, T2}\n    parent::T1\n    child::T2\n    dt1::Date# first date valid\n    dt2::Date# last date valid\n    comp_crsp_priority::Int\n    crsp_comp_priority::Int\n    function CrspCompLinkPair(\n        t1::T1,\n        t2::T2,\n        dt1::Date,\n        dt2::Date,\n        linktype::AbstractString,\n        linkprim::AbstractString\n    ) where {T1, T2}\n        comp_crsp_priority = if linkprim == \"P\"\n            3\n        elseif linkprim == \"C\"\n            2\n        elseif linkprim == \"J\"\n            1\n        end\n        crsp_comp_priority = if linktype == \"LC\"\n            8\n        elseif linktype == \"LU\"\n            7\n        elseif linktype == \"LS\"\n            6\n        elseif linktype == \"LX\"\n            5\n        elseif linktype == \"LD\"\n            4\n        elseif linktype == \"LN\"\n            3\n        elseif linktype == \"NR\"\n            2\n        elseif linktype == \"NU\"\n            1\n        end\n        new{T1, T2}(t1, t2, dt1, dt2, comp_crsp_priority, crsp_comp_priority)\n    end\nend","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"While most of the default functions for AbstractLinkPair would work with this new type (parentID, childID, min_date, max_date, Base.in), the one that does not is priority, which determines which AbstractLinkPair is preferable. Since the direction of the link matters, two new priority functions are required:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"function WRDSMerger.priority(data::CrspCompLinkPair{GVKey, T2}) where {T2<:AbstractIdentifier}\n    data.comp_crsp_priority + data.crsp_comp_priority / 10\nend\n\nfunction WRDSMerger.priority(data::CrspCompLinkPair{T1, GVKey}) where {T1<:AbstractIdentifier}\n    data.crsp_comp_priority + data.comp_crsp_priority / 10\nend","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"While this case is not used by default in this package, following similar methodology could allow for more complex priority structures.","category":"page"},{"location":"linking_internals/#Linking-Download-Functions","page":"Internals","title":"Linking Download Functions","text":"","category":"section"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"WRDSMerger.download_crsp_links\nWRDSMerger.download_comp_crsp_links\nWRDSMerger.download_comp_cik_links\nWRDSMerger.download_ibes_links\nWRDSMerger.download_option_crsp_links\nWRDSMerger.download_ravenpack_links","category":"page"},{"location":"linking_internals/#WRDSMerger.download_crsp_links","page":"Internals","title":"WRDSMerger.download_crsp_links","text":"download_crsp_links(db; main_table=\"crsp.stocknames\", stockfile=\"crsp.dsf\")\n\nRuns the following SQL code (tables are changeable by setting the main_table and stockfile keyword arguments):\n\nselect a.*, b.mkt_cap from crsp.stocknames a\n        left join (\n            select s.permno, s.namedt, s.nameenddt, avg(d.mkt_cap) as mkt_cap from crsp.stocknames s\n                inner join (select permno, date, abs(prc) * shrout as mkt_cap from crsp.dsf) as d\n                on s.permno = d.permno and s.namedt <= d.date and s.nameenddt >= d.date\n            group by s.permno, s.namedt, s.nameenddt\n            ) b\n            on a.permno = b.permno and a.namedt = b.namedt and a.nameenddt = b.nameenddt\n\nand returns a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_comp_crsp_links","page":"Internals","title":"WRDSMerger.download_comp_crsp_links","text":"download_comp_crsp_links(db; main_table=\"crsp_a_ccm.ccmxpf_linkhist\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM crsp_a_ccm.ccmxpf_linkhist\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_comp_cik_links","page":"Internals","title":"WRDSMerger.download_comp_cik_links","text":"download_comp_cik_links(db; main_table=\"comp.company\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM comp.company\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_ibes_links","page":"Internals","title":"WRDSMerger.download_ibes_links","text":"download_ibes_links(db; main_table=\"wrdsapps.ibcrsphist\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM wrdsapps.ibcrsphist\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_option_crsp_links","page":"Internals","title":"WRDSMerger.download_option_crsp_links","text":"download_option_crsp_links(db; main_table=\"optionm_all.secnmd\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM optionm_all.secnmd\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_ravenpack_links","page":"Internals","title":"WRDSMerger.download_ravenpack_links","text":"download_ravenpack_links(db; main_table=\"ravenpack.rp_entity_mapping\", cusip_list=\"crsp.stocknames\")\n\nRuns the following SQL code (tables are changeable by setting the main_table and cusip_list keyword arguments):\n\nSELECT rp_entity_id, data_value as ncusip, range_start, range_end FROM ravenpack.rp_entity_mapping as a\n            inner join (select distinct ncusip from crsp.stocknames) as b\n            on left(a.data_value, 8) = b.ncusip\n\nand returns a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#Changing-The-Priority-for-Permno","page":"Internals","title":"Changing The Priority for Permno","text":"","category":"section"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"A single company can have many securities, therefore, there might be multiple options when linking these items. For example, a single GVKey or Permco will match to multiple Permnos. In some tables in WRDS (such as in the case of GVKey <-> Permno), there are explicit primary identifier markers provided, improving the match. In others, there are not (as in Permco <-> Permno). This is a particular problem for Permno since this package prioritizes matches through Permno (as discussed in Supremacy of Permno).","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"The most common method to resolve these matches is to find the Permno that has the largest market capitalization on the day of the match since that should be the primary identifier. This is difficult to do in a package like this where the values are, ideally, predetermined. Therefore, the default behavior is to average the market capitalization over the period of the link and choose the higher average market capitalization. This behavior is convenient (requiring only a single SQL download), but potentially inconsistent with the end goal. Specifically, if one link has a lower average market capitalization (perhaps due to a long time window where the value was lower) than another link, this package might pick the Permno with a smaller market capitalization on the day of the match.","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"This is a proposed alternative that makes use of the AbnormalReturns.jl package to provide a quick lookup of the market capitalization just before the link:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"First, stock price data is required:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"using WRDSMerger, DataFramesMeta, AbnormalReturns\ndf = raw_sql(wrds_conn, \"SELECT permno, date, abs(prc) * shrout AS mkt_cap FROM crsp.dsf\")\n@rtransform!(df, :mkt_cap = coalesce(:mkt_cap, 0.0))","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"note: Note\nIt is recommended to provide some filter on the WRDS download as the crsp.dsf file has over 100 million rows, downloading this data takes a lot of ram, peaking at ~20 GB. Most obviously, selecting dates beyond a certain point helps a lot.","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"AbnormalReturns needs a market calendar, instead of downloading something, just reuse the dates from df and load that into a MarketData object:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"mkt_data = MarketData(\n    @by(df, :date, :full_mkt = mean(:mkt_cap)),\n    df\n)","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Then we need to redefine how WRDSMerger goes about choosing between two links when the outcome is a Permno. It is also important to do some error checking since AbnormalReturns does not accept cases when the date is out of the range available or the Permno is not in the dataset. WRDSMerger determines priority uses the is_higher_priority function, which checks the priority of two AbstractLinkPairs and compares them. Therefore, changing the priority function slightly when the outcome is a Permno will create the necessary changes:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"function WRDSMerger.priority(\n    data::AbstractLinkPair{T1, Permno},\n    dt::Date;\n    mkt_data=mkt_data # need the market data defined above\n) where {T1}\n    if dt < AbnormalReturns.cal_dt_min(mkt_data.calendar) || dt > AbnormalReturns.cal_dt_min(mkt_data.calendar)\n        return 0.0\n    end\n    if dt > AbnormalReturns.cal_dt_min(mkt_data.calendar)\n        # typically, the market cap on the day before is checked\n        # but it is also important to avoid going outside the calendar\n        # range\n        dt = BusinessDays.advancebdays(mkt_data.calendar, dt, -1)\n    end\n    permno_val = WRDSMerger.childID(data)\n    if haskey(mkt_data.firmdata, permno_val)\n        coalesce(\n            mkt_data[permno_val, dt, :mkt_cap], # returns value or missing\n            0.0\n        )\n    else\n        0.0\n    end\nend","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"This method is obviously slower than the default setup, but would provide the market capitalization on the day before the match.","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"This is not the default in this package since many of these operations are costly, particularly downloading the data.","category":"page"},{"location":"linking_internals/#Adding-New-Identifiers","page":"Internals","title":"Adding New Identifiers","text":"","category":"section"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"There are likely other identifiers in WRDS that are not included by default in this package, making it necessary to define a new identifier. This is quite easy. First, define a new type:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"struct IdentiferName <: FirmIdentifier\n    val::String\n    IdentifierName(x::AbstractString) = new(x)\nend\n\nWRDSMerger.value(x::IdentifierName) = x.val","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Replacing FirmIdentifier with SecurityIdentifier if necessary and choosing between String or Int or some other type.","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Next, provide the information that links this new identifier to some other identifier in the package. This is done by calling new_link_method:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"WRDSMerger.new_link_method","category":"page"},{"location":"linking_internals/#WRDSMerger.new_link_method","page":"Internals","title":"WRDSMerger.new_link_method","text":"new_link_method(data::Vector{L}) where {L<:AbstractLinkPair}\n\nnew_link_method(data::Dict{T1, Vector{L}}) where {T1, ID, L<:AbstractLinkPair{T1, ID}}\n\nfunction new_link_method(\n    ::Type{T1},\n    ::Type{ID};\n    current_links = all_pairs(AbstractIdentifier, AbstractIdentifier)\n) where {ID<:AbstractIdentifier, T1<:AbstractIdentifier}\n\nCreates a new convert_identifier method to link T1 -> ID. See detailed notes under convert_identifier. If a vector of AbstractLinkPair or a dictionary is passed, this creates a direct link method, while passing two types will attempt to find a path between the two identifiers and define the appropriate function.\n\nnote: Note\nall_pairs is a relatively slow function, needing to repeatedly check what methods are available. Therefore, if needing to create many new methods, it is best to run all_pairs once and pass that for each new T1 -> ID that needs to be created.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Specifically the method with a vector of AbstractLinkPairs or the dictionary version. Therefore, you need to create a vector of these links, I will assume use of the LinkPair type, but this can be adjusted as discussed in Defining New AbstractLinkPairs. A LinkPair requires 5 elements: the ID it is coming from (parent ID), the ID it is going to (child ID), a start and end date, and a priority (though the start and end date and priority have defaults). Therefore, it is easiest if you create a DataFrame that has similar data (i.e., a column of parent ID, child ID, start date, end date, priority). This package then has a function that allows you to create the bi-directional links required, create_link_pair:","category":"page"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"WRDSMerger.create_link_pair","category":"page"},{"location":"linking_internals/#WRDSMerger.create_link_pair","page":"Internals","title":"WRDSMerger.create_link_pair","text":"function create_link_pair(\n    ::Type{LP},\n    ::Type{T1},\n    ::Type{T2},\n    df::DataFrame,\n    cols...\n) where {T1<:AbstractIdentifier, T2<:AbstractIdentifier, LP<:AbstractLinkPair}\n\nGeneric function that creates an AbstractLinkPair based on the types and a DataFrame. cols... should be a list of column names in the DataFrame, the first being ready to convert to type T1 and the second ready to convert to type T2. This function returns a tuple of two dictionaries: (Dict{T1, LP{T1, T2}},Dict{T2, LP{T2, T1}}) which is easily passed to new_link_method.\n\nExample\n\ncreate_link_pair(\n    LinkPair,\n    Permno,\n    NCusip,\n    df,\n    :permno,\n    :ncusip,\n    :namedt,\n    :nameenddt,\n    :priority\n)\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"Since this returns a tuple of dictionaries, each needs to be passed to new_link_method to create the bidirectional links. Then, to create links beyond just T1 <-> T2, call create_all_links().","category":"page"},{"location":"linking_internals/#Other-Functions","page":"Internals","title":"Other Functions","text":"","category":"section"},{"location":"linking_internals/","page":"Internals","title":"Internals","text":"WRDSMerger.choose_best_match\nWRDSMerger.check_priority_errors\nWRDSMerger.is_higher_priority\nWRDSMerger.identify_overlaps\nWRDSMerger.value\nWRDSMerger.all_pairs","category":"page"},{"location":"linking_internals/#WRDSMerger.choose_best_match","page":"Internals","title":"WRDSMerger.choose_best_match","text":"function choose_best_match(\n    data::AbstractVector{L},\n    dt::Date;\n    allow_inexact_date=true,\n    args...\n) where {L<:AbstractLinkPair}\n\nPicks the best identifier based on the vector of links provided.\n\nArgs\n\nallow_inexact_date=true: If true, and the length of the supplied vector is 1, then is will return that value even if the supplied date does not fit within the link.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.check_priority_errors","page":"Internals","title":"WRDSMerger.check_priority_errors","text":"This function tests whether there are any dates that are in multiple AbstractLinkPairs and those links have equivalent priority. If this function returns true, then there is at least a date where there is no distinction between two links. The way choose_best_match works, the first in the vector will be chosen.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.is_higher_priority","page":"Internals","title":"WRDSMerger.is_higher_priority","text":"is_higher_priority(\n    data1::AbstractLinkPair{T1, T2},\n    data2::AbstractLinkPair{T1, T2},\n    args...\n) where {T1, T2}\n\nDetermines whether data1 has higher priority than data2. args... are automatically passed to the priorityfunction, which can then deal with special circumstances (currently passed as the date of the match). However, none of the default settings use this.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.identify_overlaps","page":"Internals","title":"WRDSMerger.identify_overlaps","text":"This function looks for overlapping periods. It takes a list of all dates and checks if individual sub periods are a subset of multiple periods.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.value","page":"Internals","title":"WRDSMerger.value","text":"value(x::AbstractIdentifier)\n\nConverts an identifier into a common Julia type (typically Int or String).\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.all_pairs","page":"Internals","title":"WRDSMerger.all_pairs","text":"function all_pairs(\n    a::Type{<:AbstractIdentifier},\n    b::Type{<:AbstractIdentifier};\n    out = Vector{Tuple{DataType, DataType}}(),\n    test_fun=base_method_exists\n)\n\nGenerates a vector of tuples for which a method exists. It specifically looks for base types (not abstract types).\n\ntest_fun has two values defined:\n\nbase_method_exists looks for methods that have the two types provided   and that link is a direct link (e.g., Permno <-> NCusip), as opposed to a   method that takes more than a single step\nmethod_is_missing looks for methods that do not exist, this is designed to   look for cases where a new method is needed, typically taking more than a   single step to complete\n\n\n\n\n\n","category":"function"},{"location":"linking_identifiers/#Identifier-Types","page":"Identifier Types","title":"Identifier Types","text":"","category":"section"},{"location":"linking_identifiers/","page":"Identifier Types","title":"Identifier Types","text":"Pages = [\"linking_identifiers.md\"]","category":"page"},{"location":"linking_identifiers/","page":"Identifier Types","title":"Identifier Types","text":"AbstractIdentifier","category":"page"},{"location":"linking_identifiers/#WRDSMerger.AbstractIdentifier","page":"Identifier Types","title":"WRDSMerger.AbstractIdentifier","text":"Supertype for all Firm Identifiers\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#Firm-Identifiers","page":"Identifier Types","title":"Firm Identifiers","text":"","category":"section"},{"location":"linking_identifiers/","page":"Identifier Types","title":"Identifier Types","text":"FirmIdentifier\nGVKey\nCIK\nPermco\nCusip6\nNCusip6\nRPEntity","category":"page"},{"location":"linking_identifiers/#WRDSMerger.FirmIdentifier","page":"Identifier Types","title":"WRDSMerger.FirmIdentifier","text":"A FirmIdentifier specifies a specific firm over a given date range and is opposed to a SecurityIdentifier. In a standard database, a single FirmIdentifier can have multiple SecurityIdentifiers but a SecurityIdentifier should only have one FirmIdentifier.\n\nExamples include GVKey, Permco and Cusip6.\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.GVKey","page":"Identifier Types","title":"WRDSMerger.GVKey","text":"GVKey <: FirmIdentifier\n\nGVKey(s::Union{<:Real, <:AbstractString})::GVKey\n\nGVKey(x::AbstractIdentifier, d::Date)::String\n\nGVKey is the primary identifier in the Compustat universe It only contains numeric values, though is often represented as a string with 6 digits, therefore, it is stored as a String.\n\nExample\n\njulia> GVKey(2968) # GVKey for Chase\nGVKey(\"002968\")\n\njulia> GVKey(\"002968\")\nGVKey(\"002968\")\n\njulia> GVKey(Permno(47896), Date(2020))\n\"002968\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.CIK","page":"Identifier Types","title":"WRDSMerger.CIK","text":"CIK <: FirmIdentifier\n\nCIK(s::Union{<:Real, <:AbstractString})::CIK\n\nCIK(x::AbstractIdentifier, d::Date)::String\n\nCIK is a common identifier outside of WRDS It only contains numeric values, though is often represented as a string with 10 digits, therefore, it is stored as a String.\n\nExample\n\njulia> CIK(19617) # CIK for Chase\nCIK(\"0000019617\")\n\njulia> CIK(\"0000019617\")\nCIK(\"0000019617\")\n\njulia> CIK(GVKey(2968), Date(2020))\n\"0000019617\"\n\njulia> CIK(GVKey(2968)) # Date for GVKey <-> CIK is unnecessary\n\"0000019617\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Permco","page":"Identifier Types","title":"WRDSMerger.Permco","text":"Permco <: FirmIdentifier\n\nPermco(x::Real)::Permco\n\nPermco(x::AbstractIdentifier, d::Date)::Int\n\nPermco is the primary firm identifier in the CRSP universe.\n\nExample\n\njulia> Permco(20436) # Permco for Chase\nPermco(20436)\n\njulia> Permco(NCusip6(\"46625H\"), Date(2020))\n20436\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Cusip6","page":"Identifier Types","title":"WRDSMerger.Cusip6","text":"Cusip6 <: FirmIdentifier\n\nCusip6(s::AbstractString)::Cusip6\n\nCusip6(x::Cusip)::Cusip6\n\nCusip6(x::AbstractIdentifier, d::Date)::String\n\nCusip6 is the firm identifier component of Cusip. It can contain numbers or letters (with a maximum length of 6 characters).\n\nnote: Note\nCusip6 is different than NCusip6. The standard in CRSP (and some other WRDS datasets) is that Cusip6 represents the most recently available NCusip6 for a given firm, while NCusip6 will provide a historical view of that firm.\n\nExample\n\njulia> Cusip6(\"46625H\") # Cusip6 for Chase\nCusip6(\"46625H\")\n\njulia> Cusip6(Cusip(\"46625H10\")) # Cusip6 is the first 6 digits of a Cusip\nCusip6(\"46625H\")\n\njulia> Cusip6(Permno(47896), Date(2020))\n\"46625H\"\n\nRelated to the note on the difference between Cusip6 and NCusip6:\n\njulia> Cusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> Cusip6(Permno(47896), Date(1998))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(1998))\n\"16161A\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.NCusip6","page":"Identifier Types","title":"WRDSMerger.NCusip6","text":"NCusip6 <: FirmIdentifier\n\nNCusip6(s::AbstractString)::NCusip6\n\nNCusip6(x::NCusip)::NCusip6\n\nNCusip6(x::AbstractIdentifier, d::Date)::String\n\nNCusip6 is the firm identifier component of NCusip. It can contain numbers or letters (with a maximum length of 6 characters).\n\nnote: Note\nNCusip6 is different than Cusip6. The standard in CRSP (and some other WRDS datasets) is that Cusip6 represents the most recently available NCusip6 for a given firm, while NCusip6 will provide a historical view of that firm.\n\nExample\n\njulia> NCusip6(\"46625H\") # NCusip6 for Chase\nNCusip6(\"46625H\")\n\njulia> NCusip6(NCusip(\"46625H10\")) # NCusip6 is the first 6 digits of a Cusip\nNCusip6(\"46625H\")\n\njulia> NCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\nRelated to the note on the difference between Cusip6 and NCusip6:\n\njulia> Cusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> Cusip6(Permno(47896), Date(1998))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(1998))\n\"16161A\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.RPEntity","page":"Identifier Types","title":"WRDSMerger.RPEntity","text":"RPEntity <: FirmIdentifier\n\nRPEntity(x::String)::RPEntity\n\nRPEntity(x::AbstractIdentifier, d::Date)::String\n\nRPEntity is used within RavenPack to identify different entities.\n\nExample\n\njulia> RPEntity(\"619882\") # RPEntity for Chase\nRPEntity(\"619882\")\n\njulia> RPEntity(NCusip6(\"46625H\"), Date(2020))\n\"619882\"\n\njulia> NCusip6(RPEntity(\"619882\"), Date(2020))\n\"46625H\"\n\nnote: Note\nThe RavenPack links are especially messy, for example, there are two links for RPEntity -> NCusip6 from 2001-01-01 - 2001-05-31, and there is not easy way to distinguish these. This package simply returns the first value in such cases\n\njulia> RPEntity(NCusip6(\"46625H\"), Date(2001, 3))\n\"619882\"\n\njulia> RPEntity(NCusip6(\"616880\"), Date(2001, 3))\n\"619882\"\n\njulia> NCusip6(RPEntity(\"619882\"), Date(2001, 3))\n\"46625H\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#Security-Identifiers","page":"Identifier Types","title":"Security Identifiers","text":"","category":"section"},{"location":"linking_identifiers/","page":"Identifier Types","title":"Identifier Types","text":"SecurityIdentifier\nPermno\nCusip\nNCusip\nTicker\nIbesTicker\nSecID","category":"page"},{"location":"linking_identifiers/#WRDSMerger.SecurityIdentifier","page":"Identifier Types","title":"WRDSMerger.SecurityIdentifier","text":"A SecurityIdentifier specifies a specific firm over a given date range and is opposed to a FirmIdentifier. In a standard database, a single FirmIdentifier can have multiple SecurityIdentifiers but a SecurityIdentifier should only have one FirmIdentifier.\n\nExamples include Permno, Cusip and Ticker.\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Permno","page":"Identifier Types","title":"WRDSMerger.Permno","text":"Permno <: SecurityIdentifier\n\nPermno(x::Real)::Permno\n\nPermno(x::AbstractIdentifier, d::Date)::Int\n\nPermno is the primary security identifier in the CRSP universe, it is also one of the most common methods of linking between databases since it is easy to find links to Cusip and Compustat (GVKey), and Cusip.\n\nExample\n\njulia> Permno(47896) # Permno for Chase\nPermno(47896)\n\njulia> Permno(NCusip6(\"46625H\"), Date(2020))\n47896\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Cusip","page":"Identifier Types","title":"WRDSMerger.Cusip","text":"Cusip <: SecurityIdentifier\n\nCusip(s::AbstractString)::Cusip\n\nCusip(issuer::AbstractString, issue::AbstractString, checksum=nothing)::Cusip\n\nCusip(x::AbstractIdentifier, d::Date)::String\n\nCusip is a common identifier within and outside of WRDS WRDS tracks older Cusips as NCusip all Cusips are made up of 3 parts, issuer (first 6 characters), issue (next 2 characters), and a checksum most databases in WRDS only use the 8 characters. If 9 digits are passed or the checksum is explicitly passed, the checksum is validated and a warning is given if it is an invalid checksum.\n\nnote: Note\nCusip is different than NCusip. The standard in CRSP (and some other WRDS datasets) is that Cusip represents the most recently available NCusip for a given firm, while NCusip will provide a historical view of that firm.\n\nnote: Note\nCusip only stores 8 characters (not the checksum digit) and, by default, only returns those 8 characters. This means that if using a join function on a set of Cusips with 9 characters and the default output, there will be no matches. It is easiest to shorten the 9 digit Cusips to 8 digits before joining.\n\nExample\n\njulia> Cusip(\"46625H10\") # Cusip for Chase\nCusip(\"46625H10\")\n\njulia> Cusip(\"46625H\", \"10\") # can also provide the parts separately\nCusip(\"46625H10\")\n\njulia> Cusip(Permno(47896), Date(2020))\n\"46625H10\"\n\nRelated to the note on the difference between Cusip and NCusip:\n\njulia> Cusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> Cusip(Permno(47896), Date(1998))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(1998))\n\"16161A10\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.NCusip","page":"Identifier Types","title":"WRDSMerger.NCusip","text":"NCusip <: SecurityIdentifier\n    \nNCusip(s::AbstractString)::NCusip\n\nNCusip(issuer::AbstractString, issue::AbstractString, checksum=nothing)::NCusip\n\nNCusip(x::AbstractIdentifier, d::Date)::String\n\nNCusip is a common identifier within and outside of WRDS WRDS tracks the most recent NCusips as Cusip all NCusips are made up of 3 parts, issuer (first 6 characters), issue (next 2 characters), and a checksum most databases in WRDS only use the 8 characters. If 9 digits are passed or the checksum is explicitly passed, the checksum is validated and a warning is given if it is an invalid checksum.\n\nnote: Note\nNCusip is different than Cusip. The standard in CRSP (and some other WRDS datasets) is that Cusip represents the most recently available NCusip for a given firm, while NCusip will provide a historical view of that firm.\n\nnote: Note\nNCusip only stores 8 characters (not the checksum digit) and, by default, only returns those 8 characters. This means that if using a join function on a set of NCusips with 9 characters and the default output, there will be no matches. It is easiest to shorten the 9 digit NCusips to 8 digits before joining.\n\nExample\n\njulia> NCusip(\"46625H10\") # NCusip for Chase\nNCusip(\"46625H10\")\n\njulia> NCusip(\"46625H\", \"10\") # can also provide the parts separately\nNCusip(\"46625H10\")\n\njulia> NCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\nRelated to the note on the difference between Cusip and NCusip:\n\njulia> Cusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> Cusip(Permno(47896), Date(1998))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(1998))\n\"16161A10\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Ticker","page":"Identifier Types","title":"WRDSMerger.Ticker","text":"Ticker <: SecurityIdentifier\n\nTicker(s::AbstractString)::Ticker\n\nTicker(x::AbstractIdentifier, d::Date)::String\n\nTicker is a stock market ticker that is often seen on the NYSE or other exchanges. It typically consists of 1-4 characters.\n\nnote: Note\nTicker should be kept distinct from IbesTicker. IbesTicker is within the IBES database and often differs from Ticker.\n\nExample\n\njulia> Ticker(\"JPM\") # Ticker for Chase\nTicker(\"JPM\")\n\njulia> Ticker(Permno(47896), Date(2020))\n\"JPM\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.IbesTicker","page":"Identifier Types","title":"WRDSMerger.IbesTicker","text":"IbesTicker <: SecurityIdentifier\n\nIbesTicker(s::AbstractString)::IbesTicker\n\nIbesTicker(x::AbstractIdentifier, d::Date)::String\n\nIbesTicker is the primary identifier in the IBES universe and typically consists of 1-4 characters.\n\nExample\n\njulia> IbesTicker(\"CHL\") # IbesTicker for Chase\nIbesTicker(\"CHL\")\n\njulia> IbesTicker(Permno(47896), Date(2020))\n\"CHL\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.SecID","page":"Identifier Types","title":"WRDSMerger.SecID","text":"SecID <: SecurityIdentifier\n\nSecID(x::Real)::SecID\n\nSecID(x::AbstractIdentifier, d::Date)::Int\n\nSecID is the primary identifier within the OptionMetrics database.\n\njulia> SecID(102936) # SecID for Chase\nSecID(102936)\n\njulia> SecID(NCusip(\"46625H10\"), Date(2020))\n102936\n\n\n\n\n\n","category":"type"},{"location":"misc_utilities/#Utilities","page":"Miscellaneous Utilities","title":"Utilities","text":"","category":"section"},{"location":"misc_utilities/","page":"Miscellaneous Utilities","title":"Miscellaneous Utilities","text":"range_join\nWRDSMerger.check_schema_perms\nWRDSMerger.approx_row_count\nWRDSMerger.modify_col!","category":"page"},{"location":"misc_utilities/#WRDSMerger.range_join","page":"Miscellaneous Utilities","title":"WRDSMerger.range_join","text":"function range_join(\n    df1::DataFrame,\n    df2::DataFrame,\n    on,\n    conditions::Array{Conditions};\n    minimize=nothing,\n    join_conditions::Union{Array{Symbol}, Symbol}=:and,\n    validate::Tuple{Bool, Bool}=(false, false),\n    jointype::Symbol=:inner\n)\n\nJoins the dataframes based on a series of conditions, designed to work with ranges\n\nArguments\n\ndf1::DataFrame: left DataFrame\ndf2::DataFrame: right DataFrame\non: either array of column names or matched pairs\nconditions::Array{Conditions}: array of Conditions, which specifies the function (<=, >, etc.), left and right columns\njointype::Symbol=:inner: type of join, options are :inner, :outer, :left, and :right\nminimize: either nothing or an array of column names or matched pairs, minimization will take place in order\njoin_conditions::Union{Array{Symbol}, Symbol}: defaults to :and, otherwise an array of symbols that is 1 less than the length of conditions that the joins will happen in (:or or :and)\nvalidate::Tuple{Bool, Bool}: Whether to validate, this works differently than the equivalent in DataFrames joins, here, validate insures that a single row from the dataframe is not duplicated. So validate=(true, false) means that there are no duplicated rows from the left dataframe in the result.\n\nExample\n\ndf1 = DataFrame(\n    firm=1:10,\n    date=Date.(2013, 1:10, 1:10)\n)\n\ndf2 = df1[:, :]\ndf2[!, :date_low] = df2.date .- Day(2)\ndf2[!, :date_high] = df2.date .+ Day(2)\nselect!(df2, Not(:date))\n\nrange_join(\n    df1,\n    df2,\n    [:firm],\n    [\n        Conditions(<, :date, :date_high),\n        Conditions(>, :date, :date_low)\n    ],\n    join_conditions=[:and]\n)\n\n\n\n\n\n","category":"function"},{"location":"misc_utilities/#WRDSMerger.check_schema_perms","page":"Miscellaneous Utilities","title":"WRDSMerger.check_schema_perms","text":"check_schema_perms(conn::Union{LibPQ.Connection, DBInterface.Connection}, library::String)\n\nVerify that the user can access a schema\n\n\n\n\n\n","category":"function"},{"location":"misc_utilities/#WRDSMerger.approx_row_count","page":"Miscellaneous Utilities","title":"WRDSMerger.approx_row_count","text":"approx_row_count(conn::Union{LibPQ.Connection, DBInterface.Connection}, library::String, table::String)\n\nGet an approximate count of the number of rows in a table\n\n\n\n\n\n","category":"function"},{"location":"misc_utilities/#WRDSMerger.modify_col!","page":"Miscellaneous Utilities","title":"WRDSMerger.modify_col!","text":"modify_col! tries to identify the real type of a column, especially for strings that are actually dates or floats that are actually integers. Almost all data downloaded from WRDS correctly specifies dates, but all numbers are stored as float8, even items like year which should be an integer. This uses multiple dispatch to check if all elements in a given column are compatible with changing type and then changes the type of the column. Note that for strings this function does not by default try to convert integer like strings to integer (such as GVKey), it only converts strings that look like a date, datetime, or time.\n\n\n\n\n\n","category":"function"},{"location":"#WRDSMerger.jl-Docs","page":"Introduction","title":"WRDSMerger.jl Docs","text":"","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"From the Julia REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]add WRDSMerger","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg; Pkg.add(WRDSMerger)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From source:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]add https://github.com/junder873/WRDSMerger.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/junder873/WRDSMerger.jl\")","category":"page"},{"location":"#Establish-DB-Connection","page":"Introduction","title":"Establish DB Connection","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package requires a subscription to WRDS and can only access datasets that are included in your subscription. There are several ways to connect to the database. The simplest and most reliable is to use LibPQ.jl, to initiate a connection run:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"conn = LibPQ.Connection(\n    \"\"\"\n        host = wrds-pgdata.wharton.upenn.edu \n        port = 9737\n        user='username' \n        password='password'\n        sslmode = 'require' dbname = wrds\n    \"\"\"\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note, running the above too many times may cause WRDS to temporarily block your connections for having too many. Run the connection at the start of your script and only rerun that part when necessary. I have found that LibPQ is the easiest way to connect to WRDS since there are no restrictions on length of query and the data has a consistent format.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Alternatively, you can connect to WRDS through an ODBC driver using ODBC.jl. I recommend following the setup steps listed under WRDS support for connecting with Stata (since that also uses ODBC). You can find that information here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The third method is if you download the data to your own database, such as a SQLite database using SQLite.jl (This is the method this package uses for testing). SQLite requires slightly different names for tables, so you will need to change the table defaults:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"conn = SQLite.DB(\"db.sqlite\")\nWRDSMerger.default_tables[\"comp_funda\"] = \"compa_funda\"\nWRDSMerger.default_tables[\"comp_fundq\"] = \"compa_fundq\"\n...","category":"page"},{"location":"#ODBC-vs-LibPQ","page":"Introduction","title":"ODBC vs LibPQ","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The two largest packages I am aware of for connecting to a Postgres database in Julia are ODBC.jl and LibPQ.jl. Both of these have various advantages.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Starting with LibPQ, adding LibPQ to your project is the full installation process. To use ODBC, an extra driver, with extra setup, needs to occur before use. In addition, as far as I can tell, LibPQ does not have a limit on length of query. Some functions in this package (such as crsp_data) create exceptionally long queries to reduce the total amount of data downloaded, which LibPQ handles easily.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For ODBC, it is considerably faster at converting data to a DataFrame. For example, downloading the full CRSP Stockfile (crsp.dsf, which includes returns for every stock for each day and is about 100 million rows), takes about 4 minutes to download and make into a DataFrame with ODBC on a gigabit connection. LibPQ takes about 24 minutes. Most of this difference appears to be type instability while converting the LibPQ result to a DataFrame, since the initial LibPQ result only takes a minute and @time reports 80% garbage collection time. ODBC also stores your password separately (in the driver settings) making it a little easier to share a project without compromising your password.","category":"page"},{"location":"download_data/#Downloading-WRDS-Data","page":"Downloading WRDS Data","title":"Downloading WRDS Data","text":"","category":"section"},{"location":"download_data/#Explore-WRDS","page":"Downloading WRDS Data","title":"Explore WRDS","text":"","category":"section"},{"location":"download_data/","page":"Downloading WRDS Data","title":"Downloading WRDS Data","text":"list_libraries\nlist_tables\ndescribe_table\nget_table\nraw_sql","category":"page"},{"location":"download_data/#WRDSMerger.list_libraries","page":"Downloading WRDS Data","title":"WRDSMerger.list_libraries","text":"list_libraries(conn::Union{LibPQ.Connection, DBInterface.Connection})\n\nLoad the list of Postgres schemata the user has permission to access\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.list_tables","page":"Downloading WRDS Data","title":"WRDSMerger.list_tables","text":"list_tables(conn::Union{LibPQ.Connection, DBInterface.Connection}, library::String)\n\nList all of the views/tables/foreign tables within a schema\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.describe_table","page":"Downloading WRDS Data","title":"WRDSMerger.describe_table","text":"describe_table(conn::Union{LibPQ.Connection, DBInterface.Connection}, library::String, table::String)\n\nGet a table's description (row count, columns, column types)\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.get_table","page":"Downloading WRDS Data","title":"WRDSMerger.get_table","text":"get_table(\n                conn::Union{LibPQ.Connection, DBInterface.Connection},\n                library::String,\n                table::String;\n                obs::Union{Nothing, Int} = nothing,\n                offset::Int = 0,\n                cols = nothing\n            )\n\nCreate a DataFrame from a table\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.raw_sql","page":"Downloading WRDS Data","title":"WRDSMerger.raw_sql","text":"raw_sql(\n    conn::Union{LibPQ.Connection, DBInterface.Connection},\n    query::String\n)\n\nExecutes raw sql code, and converts code to a DataFrame\n\n\n\n\n\n","category":"function"},{"location":"download_data/#Compustat","page":"Downloading WRDS Data","title":"Compustat","text":"","category":"section"},{"location":"download_data/","page":"Downloading WRDS Data","title":"Downloading WRDS Data","text":"comp_data","category":"page"},{"location":"download_data/#WRDSMerger.comp_data","page":"Downloading WRDS Data","title":"WRDSMerger.comp_data","text":"function comp_data(\n    conn::Union{LibPQ.Connection, DBInterface.Connection}[,\n    gvkeys::AbstractArray{String},]\n    dateStart::Union{Date,Int}=1950,\n    dateEnd::Union{Date,Int}=Dates.today();\n    annual::Bool=true,\n    filters::Dict{String,<:Any}=Dict(\n        \"datafmt\" => \"STD\",\n        \"indfmt\" => \"INDL\",\n        \"consol\" => \"C\",\n        \"popsrc\" => \"D\"\n    ),\n    cols::Array{String}=[\"gvkey\", \"datadate\", \"fyear\", \"sale\", \"revt\", \"xopr\"]\n)\n\nDownloads data from Compustat for firms (if list of gvkeys is provided, filters to those firms) available firms over a period. Data can be annual (set annual=true) or quarterly (set annual=false). For quarterly data, you also likely need to change the columns that are downloaded (ie, sales is \"saleq\" in quarterly data).\n\nFilters is a dictionary of String => String (or array of String) pairings that will be applied to the SQL query.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#CRSP","page":"Downloading WRDS Data","title":"CRSP","text":"","category":"section"},{"location":"download_data/","page":"Downloading WRDS Data","title":"Downloading WRDS Data","text":"crsp_stocknames\ncrsp_market\ncrsp_data\ncrsp_delist\ncrsp_adjust","category":"page"},{"location":"download_data/#WRDSMerger.crsp_stocknames","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_stocknames","text":"function crsp_stocknames(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    cols::Array{String}=[\"permno\", \"cusip\", \"ncusip\", \"comnam\", \"namedt\", \"nameenddt\", \"ticker\"]\n)\n\nfunction crsp_stocknames(\n    conn::Union{LibPQ.Connection, DBInterface.Connection},\n    cusip::Array{String};\n    cols::Array{String}=[\"permno\", \"cusip\", \"ncusip\", \"comnam\", \"namedt\", \"nameenddt\", \"ticker\"],\n    cusip_col=\"cusip\", # either \"cusip\" \"ncusip\" or \"ticker\"\n)\n\nfunction crsp_stocknames(\n    conn::Union{LibPQ.Connection, DBInterface.Connection},\n    permno::Array{<:Number};\n    cols::Array{String}=[\"permno\", \"cusip\", \"ncusip\", \"comnam\", \"namedt\", \"nameenddt\", \"ticker\"],\n)\n\nDownload crsp.stockname data (with non-missing ncusip). If an array of strings is passed, by default assumes it is a list of cusips, can be a list of ncusip or tickers (change cusip_col). Can also take an array of numbers which is assumed to be a list of permnos.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_market","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_market","text":"function crsp_market(\n    conn::Union{LibPQ.Connection, DBInterface.Connection},\n    dateStart::Union{Date,Int}=1950,\n    dateEnd::Union{Date,Int}=Dates.today();\n    col::Union{String, Array{String}}=\"vwretd\"\n)\n\nDownloads the data from the daily or monthly stock index file (dsi and msi) for a range of dates with one value for each day (with various return columns). Available columns are:\n\n\"vwretd\": Value weighted return with dividends\n\"vwretx\": Value weighted return without dividends\n\"ewretd\": Equal weighted return with dividends\n\"ewretx\": Equal weighted return without dividends\n\"sprtrn\": S&P500 return\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_data","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_data","text":"function crsp_data(\n    conn::Union{LibPQ.Connection, DBInterface.Connection},\n    [permnos::Vector{<:Real},]\n    s::Date=Date(1925),\n    e::Date=today();\n    cols = [\"ret\", \"vol\", \"shrout\"],\n    filters::Dict{String, <:Any}=Dict{String, Any}(),\n    adjust_crsp_data::Bool=true\n)\n\nfunction crsp_data(\n    conn::Union{LibPQ.Connection, DBInterface.Connection},\n    permnos::Vector{<:Real},\n    dates::Vector{Date},\n    [dates_end::Vector{Date}];\n    cols=[\"ret\", \"vol\", \"shrout\"],\n    adjust_crsp_data::Bool=true,\n    query_size_limit::Int=3000\n)\n\nDownloads data from the crsp stockfiles, which are individual stocks. To download the data from the monthly stockfile, change the default table to the monthly stockfile:\n\nWRDSMerger.default_tables[\"crsp_stock_data\"] = \"crsp.msf\"\nWRDSMerger.default_tables[\"crsp_index\"] = \"crsp.msi\"\nWRDSMerger.default_tables[\"crsp_delist\"] = \"crsp.msedelist\"\n\nArguments\n\npermnos::Vecotr{<:Real}: A vector of firm IDs, if provided, will only download data for those firms\ns::Date=Date(1925) and e::Date=today(): Downloads all data between two dates provided\ndates::Vector{Date}: Downloads data for a set of permnos on the date provided\ndates_end::Vector{Date}: If provided, then treats the dates as the start of a period and will download data for the permnos between the two dates\nadjust_crsp_data::Bool=true: This will call crsp_adjust with all options   set to true, it will only do the operations that it has the data for.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_delist","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_delist","text":"function crsp_delist(\n    conn::Union{LibPQ.Connection, DBInterface.Connection};\n    cols::Array{String}=[\n        \"permno\",\n        \"dlstdt\",\n        \"dlret\"\n    ],\n    date_start::Date=Date(1926),\n    date_end::Date=today()\n)\n\nFetches the CRSP delist dataset, typically for the returns on the day of delisting.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_adjust","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_adjust","text":"function crsp_adjust(\n    conn,\n    df::DataFrame;\n    kwargs...\n)\n\nThis makes 4 common adjustments to CRSP data:\n\nWhen the price in CRSP is negative, that means there was not a specific close price. Typically, researchers take the absolute value to get the actual price.\nPrices are not adjusted for splits (returns are). CRSP includes the number (cfascpr) that will adjust prices to be comparable through time\nSimilar to prices, shares outstanding are not adjusted. The number used to adjust is different due to various events.\nPrices are not adjusted for delisting, so this downloads the necessary dataset and adjusts returns accordingly.\n\nArguments\n\nOptions on what to adjust\n\nadjustprcnegatives::Bool=true: Corresponds to (1) above\nadjustprcsplits::Bool=true: Corresponds to (2) above\nadjustshrsplits::Bool=true: Corresponds to (3) above\nadjust_delist::Bool=true: Corresponds to (4) above\n\nPre-existing column names\n\ndate::String=\"date\": date column\nidcol::String=\"permno\": primary identifier (permno) column\nprc_col::String=\"prc\": price column\nret_col::String=\"ret\": return column\nprcsplitscol::String=\"cfacpr\": price split adjustment factor\nshrout_col::String=\"shrout\": shares outstanding\nshroutsplitscol::String=\"cfacshr\": share split adjustment factor\n\nOptions to relabel columns\n\nadjustednegprc_col::String=\"prc\": relabel prices to this after taking absolute value\nadjustedprccol::String=\"prc_adj\": relabel prices to this after adjusting for splits\nadjustedshroutcol::String=\"shrout_adj\":relabel shares outstanding to this after adjusting for splits\n\n\n\n\n\n","category":"function"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"data_dir = joinpath(\"..\", \"..\", \"test\", \"data\")\nusing CSV, DataFrames, WRDSMerger, Dates\nfiles = [\n    \"crsp_links\",\n    \"crsp_comp_links\",\n    \"gvkey_cik_links\",\n    \"ibes_links\",\n    \"option_links\",\n    \"ravenpack_links\"\n]\nfuns=[\n    generate_crsp_links,\n    generate_comp_crsp_links,\n    generate_comp_cik_links,\n    generate_ibes_links,\n    generate_option_crsp_links,\n    generate_ravenpack_links\n]\nfor (file, fun) in zip(files, funs)\n    fun(\n        DataFrame(\n            CSV.File(joinpath(data_dir, file * \".csv\"))\n        )\n    )\nend","category":"page"},{"location":"default_behavior/#Default-Behavior","page":"Default Behavior","title":"Default Behavior","text":"","category":"section"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"This package has some defaults that are important to be aware of during use.","category":"page"},{"location":"default_behavior/#Different-Return-Types","page":"Default Behavior","title":"Different Return Types","text":"","category":"section"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"The general design principal in Julia is that if a type is a function name, it should return that type. In this package, this is not always the case. When an AbstractIdentifier uses an external type (e.g. Int), it will return that AbstractIdentifier. However, when an AbstractIdentifier is used on another AbstractIdentifier, it will most often return the underlying value. For example:","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Permno(47896) # returns the type Permno\nPermno(Permco(20436), Date(2020)) # an Int type","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"The reason for this difference is that the AbstractIdentifier types are primarily meant for internal use and communicating information to the functions, but it is more often necessary to have the common Julia type for later joins. If it is needed to have the AbstractIdentifier, then run:","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"WRDSMerger.convert_identifier(Permno, Permco(20436), Date(2020))","category":"page"},{"location":"default_behavior/#Default-Options-in-Conversions","page":"Default Behavior","title":"Default Options in Conversions","text":"","category":"section"},{"location":"default_behavior/#Parent-Firms","page":"Default Behavior","title":"Parent Firms","text":"","category":"section"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Certain SecurityIdentifiers have a direct link to a parent firm, most obviously Cusip and NCusip (with Cusip6 and NCusip6). In certain situations, it can make sense to allow a match to occur through these parent firms, such as when the end goal is to match a SecurityIdentifier to a FirmIdentifier.","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"For example, consider the case of NCusip(\"46625H21\"), which is not in the data. Therefore, when trying to convert his to another SecurityIdentifier, it will return missing since there is not an exact match:","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Permno(NCusip(\"46625H21\"), Date(2020))","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"However, if trying to match this NCusip to a FirmIdentifier, then it will return a match:","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Permco(NCusip(\"46625H21\"), Date(2020))","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"This is because while the NCusip is not in the data, the NCusip6(\"46625H\") is:","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Permco(NCusip6(\"46625H\"), Date(2020))","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"The logic here is that it should not matter if a particular security does not match to a firm if the parent firm of that security does match to a firm. This is very useful if the integrity of the Cusip values is in question. This behavior can be disabled or enabled by setting allow_parent_firm;","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Permno(NCusip(\"46625H21\"), Date(2020); allow_parent_firm=true)\nPermco(NCusip(\"46625H21\"), Date(2020); allow_parent_firm=false)","category":"page"},{"location":"default_behavior/#Outside-of-Date-Ranges-and-Singular-Matches","page":"Default Behavior","title":"Outside of Date Ranges and Singular Matches","text":"","category":"section"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Many links are supposed to be only valid for a specific date range. For example, linking NCusip(\"16161A10\") to Permno(47896) is only valid between 1996-04-01 to 2001-01-01. However, this NCusip only ever links to that Permno, so the default behavior in this package is to provide that match:","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Permno(NCusip(\"16161A10\"), Date(2020)) # outside date range","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"If the link does not only provide one potential result (e.g., if that NCusip also could go to a different Permno), then this will return missing. The default behavior can be disabled by setting allow_inexact_date=false:","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"Permno(NCusip(\"16161A10\"), Date(2020); allow_inexact_date=false) # outside date range","category":"page"},{"location":"default_behavior/#Supremacy-of-Permno","page":"Default Behavior","title":"Supremacy of Permno","text":"","category":"section"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"In WRDS, Permnos are one of the easiest items to link. For example, there are easily accessible tables for linking GVKey <-> Permno, IbesTicker <-> Permno, and NCusip <-> Permno. This makes it very useful for most links. Therefore, when this package is determining the best path for linking two identifiers that are not directly linked (e.g., RPEntity <-> GVKey), this package will default to using Permno even if other paths exist of equal length.","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"For example, by default, this package links RPEntity to NCusip6. NCusip6 has direct links to both Permno and Permco, both of which directly link to GVKey. The default in this package will choose the path that goes through Permno (RPentity -> NCusip6 -> Permno -> GVKey).","category":"page"},{"location":"default_behavior/","page":"Default Behavior","title":"Default Behavior","text":"note: Note\nIf there is a shorter path, then it will still choose that (e.g., SecID -> NCusip -> NCusip6 -> RPEntity instead of SecID -> NCusip -> Permno -> NCusip6 -> RPEntity).","category":"page"}]
}
